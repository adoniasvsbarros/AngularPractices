List of Snippets/Concepts important inside the course

#####################################################################################################
SECTION 1 - GETTING STARTED
#####################################################################################################

* Angular CLI (Command Line Interface) commands to start a project

npm install -g @angular/cli
ng new [app_name]
cd [app_name]
ng serve

#####################################################################################################
SECTION 2 - THE BASICS
#####################################################################################################

* Creating a new component from the CLI
ng generate component [component_name]
ng g c [component_name]


* Referencing HTML and CSS in a component
Inside the @Component

referencing an external html:  templateUrl: './[component_name].component.html',
referencing an internal html:  template: `html comes here`
referencing an external css:    styleUrls: [ './path_to_css']
referencing an internal css:    styles: [`style { property: property }`]

* String interpolation
    - typescript 
        export class ServerComponent {
            serverId = 10;
            serverStatus = 'offline';

            getServerStatus(){
                return this.serverStatus;
            }
        }
    - html
        <p>Server with ID {{ serverId }} is {{ getServerStatus() }} </p>

* Property Binding
    - typescript
        export class ServersComponent implements OnInit {
            allowNewServer = false;

            constructor() { 
                setTimeout(() => {
                this.allowNewServer = true;
                } ,2000);
            }
        }
    - html
        <button [disabled]="!allowNewServer">Add server</button>
        <p [innerText]="allowNewServer"></p>

* Event Binding
    - typescript
        export class ServersComponent implements OnInit {
            allowNewServer = false;
            serverCreationStatus = 'No server was created'

            onCreateServer(){
                this.serverCreationStatus = 'Server was created'
            }

        }
    - html
        <button (click)="onCreateServer()">Add server</button>

* Two Way Binding
    - typescript
        export class ServersComponent implements OnInit {
            serverName = 'TestServer';

            onUpdateServerName(event: any){
                this.serverName = (<HTMLInputElement>event.target).value
            }
        }
    - html
        <p [innerText]="serverName"></p>
        <input 
            type="text"
            class="form-control"
            [(ngModel)]="serverName">

* ngIf directive
    <p *ngIf="serverCreated; else noServer">Server was created, servername is {{ serverName }} </p>
    <ng-template #noServer>
        <p>No server was created </p>
    </ng-template>

* ngFor directive
    <app-server *ngFor="let server of servers"></app-server>

* ngStyle directive and ngClass directive
    <p 
        [ngStyle]="{backgroundColor: getColor()}"
        [ngClass]="{online: serverStatus === 'online'}">
        Server with ID {{ serverId }} is {{ getServerStatus() }} 
    </p>


#####################################################################################################
SECTION 5 - COMPONENTS & DATABINDING DEEP DIVE
#####################################################################################################

* Binding to custom property
    - element typescript
        export class ServerElementComponent implements OnInit {
            @Input() element: {type: string, name: string, content: string};
        }
    - app html
        <app-server-element 
            *ngFor="let serverElement of serverElements"
            [element]="serverElement">
        </app-server-element>

    * Assigning it an alias
        - typescript
            @Input('propertyAlias')
        - html
            <element [propertyAlias] = "variable"></element>

* Binding to custom event
    - app typescript (listening event)
        onServerAdded(serverData: {serverName: string, serverContent: string}) {
            this.serverElements.push({
            type: 'server',
            name: serverData.serverName,
            content: serverData.serverContent
            }); 
        }

    - app html
        <app-cokpit 
            (serverCreated)="onServerAdded($event)"
            (bpCreated)="onBlueprintAdded($event)" >
        </app-cokpit>

    - element typescript (invoking event)
        export class CokpitComponent implements OnInit {
            @Output() serverCreated = new EventEmitter<{serverName: string, serverContent: string}>();

            onAddServer() {
                this.serverCreated.emit({
                serverName: this.newServerName, 
                serverContent: this.newServerContent
                });
            }
        }
    
    - element html
        <div>
            <label>Server Name</label>
            <input type="text" class="form-control" [(ngModel)]="newServerName">
            <label>Server Content</label>
            <input type="text" class="form-control" [(ngModel)]="newServerContent">
            <br>
            <button
            class="btn btn-primary"
            (click)="onAddServer()">Add Server</button>
        </div>

    * Assigning it alias
        - typescript
            @Output('bpCreated')
        - html
            (bpCreated)="onBlueprintAdded($event)" 

*  Changing view encapsulation
    @Component({
        encapsulation: ViewEncapsulation.None // sets css globally, other opts are none, emulated, and shadowdom
    })

* Using local references in templates
    - html
    <input type="text" class="form-control" [(ngModel)]="newServerName" #serverNameInput> (works in the element)
    serverNameInput.value catchs the value inserted in the input

    <button
        class="btn btn-primary"
        (click)="onAddServer(serverNameInput)">Add Server</button>

    - typescript
        onAddServer(nameInput: HTMLInputElement) {
            this.serverCreated.emit({
            serverName: nameInput.value, 
            serverContent: this.newServerContent
         });
  }

* Getting access to template and DOM with @ViewChild
    - html
        <input 
        type="text" 
        class="form-control"  
        #serverNameInput>

    - typescript
        export class CokpitComponent implements OnInit {
            @ViewChild('serverNameInput', {static: true}) serverContentInput: ElementRef;
         
            onAddServer(nameInput: HTMLInputElement) {
            console.log(this.serverContentInput);
            this.serverCreated.emit({
            serverName: nameInput.value, 
            serverContent: this.serverContentInput.nativeElement.value
            });
            }
        }

* Projecting content into components with ng-content
    - element html
        <div
        class="panel panel-default">
            <div class="panel-heading">{{ element.name }}
            </div>
            <div class="panel-body">
                <ng-content></ng-content>
            </div>
        </div>

    - parent html

        <app-server-element 
        *ngFor="let serverElement of serverElements"
        [srvElement]="serverElement">
          <p>
            <strong *ngIf="element.type === 'server'" style="color: red">{{ element.content }}</strong>
            <em *ngIf="element.type === 'blueprint'">{{ element.content }}</em>
          </p>
        </app-server-element>

    * The p tag content inside the >< will be injected into the element html

* Lifecycle Hooks
    - ngOnChanges
    - ngOnInit
    - ngDoCheck
    - ngAfterContentInit
    - ngAfterContentChecked
    - ngAfterViewInit
    - ngAfterViewChecked
    - ngOnDestroy

* Getting access to ng-content with content ContentChild
    - html
        <p #contentParagraph>
    - typescript
        @ContentChild('contentParagraph', {static: true}) paragraph : ElementRef;

        console.log('text content of paragraph ' + this.paragraph.nativeElement.textContent);


#####################################################################################################
SECTION 7 - DIRECTIVES DEEP DIVE
#####################################################################################################

    * Basic attribute directive
        typescript
            @Directive({
                selector: '[appBasicHighlight]'
            })
            export class BasicHighlightDirective implements OnInit{
                constructor(private elementRef: ElementRef) {
                }

                ngOnInit() {
                    this.elementRef.nativeElement.style.backgroundColor = 'green';
                }
            }
        html
            <p appBasicHighlight>Style with basic directive</p>

    * Improved attribute directive
        typescript
            @Directive({
                selector: '[appBetterHighlight]'
            })
            export class BetterHighlightDirective implements OnInit{
                constructor(private elRef: ElementRef, private renderer: Renderer2) { }

                ngOnInit(){
                    this.renderer.setStyle(this.elRef.nativeElement, 'background-color', 'blue')
                }
            }

        html
            <p appBetterHighlight>Style with basic directive</p>

    * Using HostListener to listen to host events
        @HostListener('mouseenter') mouseover(eventData: Event) {
            this.renderer.setStyle(this.elRef.nativeElement, 'background-color', 'blue')
        }

        @HostListener('mouseleave') mouseleave(eventData: Event) {
            this.renderer.setStyle(this.elRef.nativeElement, 'background-color', 'transparent')
        }
    
    * Using HostBinding to bind to host properties
        @HostBinding('style.backgroundColor') backgroundColor: string = 'transparent';

          @HostListener('mouseenter') mouseover(eventData: Event) {
            this.backgroundColor = 'blue';
        }

    * Binding to directive properties
        typescript
            @Directive({
                selector: '[appBetterHighlight]'
            })
            export class BetterHighlightDirective implements OnInit{
                @Input() defaultColor: string = 'transparent';
                @Input('appBetterHighlight') highlightColor: string = 'blue';
                @HostBinding('style.backgroundColor') backgroundColor: string = this.defaultColor;

                constructor(private elRef: ElementRef, private renderer: Renderer2) { }

                ngOnInit(){
                    this.backgroundColor = this.defaultColor;
                }

                @HostListener('mouseenter') mouseover(eventData: Event) {
                    this.backgroundColor = this.highlightColor;
                }

                @HostListener('mouseleave') mouseleave(eventData: Event) {
                    this.backgroundColor = this.defaultColor;
                }
            }
        html
            <p [appBetterHighlight]="'red'" defaultColor="yellow">Style with basic directive</p>
            <p [appBetterHighlight]="'red'" [defaultColor]="'yellow'">Style with basic directive</p>
    * Behind the scenes of structural directives 
        this

        <div *ngIf="!onlyOdd">
            <li
                class="list-group-item"
                [ngClass]="{odd: even % 2 !== 0}"
                [ngStyle]="{backgroundColor: even % 2 !== 0 ? 'yellow' : 'transparent'}"
                *ngFor="let even of evenNumbers">
                {{ even }}
            </li>
        </div>

        becomes

        <ng-template [ngIf]="!onlyOdd">
            <div>
                <li>
                    class="list-group-item"
                    [ngClass]="{odd: even % 2 !== 0}"
                    [ngStyle]="{backgroundColor: even % 2 !== 0 ? 'yellow' : 'transparent'}"
                    *ngFor="let even of evenNumbers">
                    {{ even }}
                </li>
            </div>
        </ng-template>

    * Structural Directive
        html
            <div *appUnless="onlyOdd">
                <li
                    class="list-group-item"
                    [ngClass]="{odd: even % 2 !== 0}"
                    [ngStyle]="{backgroundColor: even % 2 !== 0 ? 'yellow' : 'transparent'}"
                    *ngFor="let even of evenNumbers">
                        {{ even }}
                </li>
            </div>
        typescript
            @Directive({
                selector: '[appUnless]'
            })
            export class UnlessDirective {
                @Input() set appUnless(condition: boolean){
                    if(!condition){
                    this.vcRef.createEmbeddedView(this.templateRef);
                    } else {
                    this.vcRef.clear();
                    }
                }
                constructor(private templateRef: TemplateRef<any>, private vcRef: ViewContainerRef) { }
            }

    * ngSwitch
        <div [ngSwitch]="value">
            <p *ngSwitchCase="5">Value is 5</p>
            <p *ngSwitchCase="10">Value is 10</p>
            <p *ngSwitchCase="100">Value is 100</p>
            <p *ngSwitchDefault >Value is Default</p>
        </div>


#####################################################################################################
SECTION 9 - USING SERVICES AND DEPENDENCY INJECTION
#####################################################################################################
    * Creating a Service and Injecting it
        service example
            export class LoggingService {
                logStatusChange(status: string){
                    console.log('A server status changed, new status: ' + status);
                }
            }

        class that uses the service
            @Component({
                providers: [LoggingService]
            })
            export class AccountComponent {

                constructor(private loggingService: LoggingService) {}

                onSetTo(status: string) {
                    this.loggingService.logStatusChange(status);
                }
            }

    * Using a service into another service
            @Injectable()
            export class AccountService {
                accounts = [
                    {
                    name: 'Master Account',
                    status: 'active'
                    }
                ];

                constructor(private loggingService: LoggingService){}

                addAccount(name: string, status: string){
                    this.accounts.push({name: name, status: status});
                    this.loggingService.logStatusChange(status);
                }

            }
    
    * A service provided somewhere on module level is an app-wide Singleton (if it is not overwritten somewhere on component level).
    * A service provided in a component shares the same instance between this component and its descendants (if it is not overwritten there).
    
    * Providing a service globaly
        @NgModule({
            declarations: [
            ],
            imports: [
            ],
            providers: [ShoppingListService],
            
        })
        export class AppModule { }
            
#####################################################################################################
SECTION 11 - CHANGING PAGES WITH ROUTES
#####################################################################################################

    * Setting up and loading routes
        ts
            import { Routes, RouterModule } from '@angular/router'
            
            const appRoutes: Routes = [
                {path: '', component: HomeComponent},
                {path: 'users', component: UsersComponent},
                {path: 'servers', component: ServersComponent}
            ]

            @NgModule({
                declarations: [
                ],
                imports: [
                    RouterModule.forRoot(appRoutes)
                ],
                providers: [],
                bootstrap: []
            })
            export class AppModule { }
    
        html
            <router-outlet></router-outlet>
    * Navigating with router links
      <ul class="nav nav-tabs">
        <li 
          role="presentation" 
          routerLinkActive="active"
          [routerLinkActiveOptions]="{exact: true}">
          <a routerLink="/">Home</a></li>
        <li 
          role="presentation" 
          routerLinkActive="active"  -> Directive that appends the class active when path is active
          [routerLinkActiveOptions]="{exact: true}" -> Especify that just add active class if the full path is active
          >
          <a routerLink="/servers">Servers</a></li>
        <li 
          role="presentation" 
          routerLinkActive="active"
          [routerLinkActiveOptions]="{exact: true}">
          <a [routerLink]="['/users']">Users</a></li>
      </ul>

    * Navigating programatically
        import { Router } from '@angular/router';
        export class HomeComponent implements OnInit {

            constructor(private router: Router) { }

            onLoadServers(){
                this.router.navigate(['/servers']);
            }
        }

    * Navigate with relative path
        import { Router, ActivatedRoute } from '@angular/router';
        export class ServersComponent implements OnInit {
            private servers: {id: number, name: string, status: string}[] = [];

            constructor(private router: Router, private route: ActivatedRoute) { }

            onReload(){
                this.router.navigate(['servers'], {relativeTo: this.route})
            }

        }

        * the default relative path is the root path

    * Dinamically using parameters in routes
        const appRoutes: Routes = [
            {path: '', component: HomeComponent},
            {path: 'users/:id', component: UserComponent}
        ]

    * Fetching route parameters
      app.module.ts
        const appRoutes: Routes = [
            {path: 'users/:id/:name', component: UserComponent}
        ]

      user.component.ts
        export class UserComponent implements OnInit {
            user: {id: number, name: string};

            constructor(private route: ActivatedRoute) { }

            ngOnInit() {
                this.user = {
                    id: this.route.snapshot.params['id'],
                    name: this.route.snapshot.params['name']
                }
            
                this.route.params.subscribe(
                    (params) => {
                        this.user.id = params['id'];
                        this.user.name = params['name'];
                    }
                );
            }
        }

      user.component.html
        <p>User with {{ user.id }} loaded.</p>
        <p>User name is {{ user.name }}</p>
    
    * When using your own observables, remember to unsubscribe them
        import { Subscription } from 'rxjs';

        export class UserComponent implements OnInit, OnDestroy {
        
            paramsSubscription: Subscription;

            ngOnDestroy() {
                this.paramsSubscription.unsubscribe();
            }
            
        }

    * Passing query parameters and fragments
        static
            <a
                [routerLink]="['/servers', server.id]"
                [queryParams]="{allowEdit:'1'}"
                fragment="loading"
                href="#"
                class="list-group-item"
                *ngFor="let server of servers">
                {{ server.name }}
            </a>
        dinamic
            this.router.navigate(['/servers', id, 'edit'], {queryParams: {allowEdit: '1'}, fragment: 'loading'});

    * Retrieving query params and fragments
        
        constructor(private route: ActivatedRoute) { }
        
        ngOnInit() {
            console.log(this.route.snapshot.queryParams);
            console.log(this.route.snapshot.fragment);
            this.route.queryParams.subscribe();
            this.route.fragment.subscribe();
            this.route.params.subscribe();
        }

    * Nested (Child) routes
        const appRoutes: Routes = [
            {path: 'servers', component: ServersComponent, children: [
                {path: ':id', component: ServerComponent},
                {path: ':id/edit', component: EditServerComponent}
            ]}
        ]

        html (when using a child component, we need to add a router outlet )
            <router-outlet></router-outlet>

    * Using query params
        servers html
            <a
                [routerLink]="['/servers', server.id]"
                [queryParams]="{allowEdit: server.id === 3 ? '1' : '0'}"
                fragment="loading"
                href="#"
                class="list-group-item"
                *ngFor="let server of servers">
                {{ server.name }}
            </a>

        server html
            <button class="btn btn-primary" (click)="onEdit()">Edit Server</button>

        server ts
            export class ServerComponent implements OnInit {
                server: {id: number, name: string, status: string};

                constructor(private serversService: ServersService,
                    private route: ActivatedRoute,
                    private router: Router) { }

                ngOnInit() {
                    const id = +this.route.snapshot.params['id'];
                    this.server = this.serversService.getServer(1);
                    this.route.params
                    .subscribe(
                        (params: Params) => {
                        this.server = this.serversService.getServer(+params['id']);
                        }
                    )
                }

                onEdit(){
                    this.router.navigate(['edit'], {relativeTo: this.route, queryParamsHandling: 'preserve'});
                }
            }
        edit server ts
            export class ServerComponent implements OnInit {
                server: {id: number, name: string, status: string};
                constructor(private serversService: ServersService,
                    private route: ActivatedRoute) { }

                ngOnInit() {
                    this.route.queryParams.subscribe(
                    (queryParams: Params) => {
                        this.allowEdit = queryParams['allowEdit'] === '1' ? true : false;
                    }
                    );

                    this.server = this.serversService.getServer(1);
                    this.serverName = this.server.name;
                    this.serverStatus = this.server.status;
                }

        edit server html
            <h4 *ngIf="!allowEdit">You're not allowed to edit</h4>
            <div *ngIf="allowEdit">    
                ...
            </div>


    * Configuring the handling of query params
        This queryParamsHandling passes the params to the route we are navigating to

        export class ServerComponent implements OnInit {
            server: {id: number, name: string, status: string};

            constructor(private serversService: ServersService,
                private route: ActivatedRoute,
                private router: Router) { }


            onEdit(){
                this.router.navigate(['edit'], {relativeTo: this.route, queryParamsHandling: 'preserve'});
            }

        }

    * Redirecting and Wildcard Routes
        Remember to use the wildcard ** after all the other routes

        const appRoutes: Routes = [
            {path: '', component: HomeComponent},
            {path: 'users', component: UsersComponent, children: [
            {path: 'not-found', component: PageNotFoundComponent},
            {path: '**', redirectTo: '/not-found', pathMatch: 'full'}
        ]

    * Outsorcing the route configuration
        app.module.ts
            @NgModule({
            declarations: [
                ...
            ],
            imports: [
                ...,
                AppRoutingModule
            ],
            providers: [...],
            bootstrap: [...]
            })
            export class AppModule { }


        app-routing.module.ts

        const appRoutes: Routes = [
            {path: '', component: HomeComponent},
            {path: 'users', component: UsersComponent, children: [
            {path: ':id/:name', component: UserComponent}
            ]},
            {path: 'servers', component: ServersComponent, children: [
            {path: ':id', component: ServerComponent},
            {path: ':id/edit', component: EditServerComponent}
            ]},
            {path: 'not-found', component: PageNotFoundComponent},
            {path: '**', redirectTo: '/not-found', pathMatch: 'full'}
        
        ];
        
        @NgModule({
            imports: [
                RouterModule.forRoot(appRoutes)
            ],
            exports: [RouterModule]
        })
        export class AppRoutingModule {

        }
    
    * Protecting routes with canActivate

        * Fake Auth Service

        auth.service.ts
            export class AuthService {
                loggedIn = false;

                isAuthenticated() {
                    const promise = new Promise(
                        (resolve, reject) => {
                            setTimeout( () => {
                                resolve(this.loggedIn)
                            }, 800);
                        }
                    );

                    return promise;
                }

                login() {
                    this.loggedIn = true;
                }

                logout() {
                    this.loggedIn = false;
                }
            }
        

        home.component.html
            <button class="btn btn-default" (click)="onLogin()">Login</button>
            <button class="btn btn-default" (click)="onLogout()">Logout</button>
        
        home.component.ts
            export class HomeComponent implements OnInit {

                constructor(private router: Router, private authService: AuthService) { }
                    ...

                onLogin(){
                    this.authService.login();
                }

                onLogout(){
                    this.authService.logout();
                }
            }

        * //

        auth-guard.service.ts
            @Injectable()
            export class AuthGuard implements CanActivate {
                
                constructor(private authService: AuthService, private router: Router) {}

                canActivate(route: ActivatedRouteSnapshot, 
                    state: RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean {
                        return this.authService.isAuthenticated()
                            .then(
                                (authenticated: boolean) => {
                                    if(authenticated) {
                                        return true;
                                    } else {
                                        this.router.navigate(['/']);
                                        return false;
                                    }
                                }
                            )
                    }
            }
        
        app.module.ts
            @NgModule({
            declarations: [
                ...
            ],
            imports: [
                ...,
                AppRoutingModule
            ],
            providers: [..., AuthService, AuthGuard],
            bootstrap: [...]
            })
            export class AppModule { }

        app-routing.module.ts
            const appRoutes: Routes = [
                ...,
                {path: 'servers', canActivate: [AuthGuard], component: ServersComponent, children: [
                {path: ':id', component: ServerComponent},
                {path: ':id/edit', component: EditServerComponent}
                ]},
                ...
            ];
    
    * Protecting only the child routes
        auth-guard.service.ts
            @Injectable()
            export class AuthGuard implements CanActivate, CanActivateChild {
                
                constructor(private authService: AuthService, private router: Router) {}

                canActivate(route: ActivatedRouteSnapshot, 
                    state: RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean {
                        return this.authService.isAuthenticated()
                            .then(
                                (authenticated: boolean) => {
                                    if(authenticated) {
                                        return true;
                                    } else {
                                        this.router.navigate(['/']);
                                        return false;
                                    }
                                }
                            )
                }

                canActivateChild(route: ActivatedRouteSnapshot, 
                    state: RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean {
                        return this.canActivate(route, state);
                }
            }


        app-routing.module.ts
            
            const appRoutes: Routes = [
                ...,
                {path: 'servers', 
                canActivateChild: [AuthGuard],
                component: ServersComponent, 
                children: [
                {path: ':id', component: ServerComponent},
                {path: ':id/edit', component: EditServerComponent}
                ]},
                ...
            
            ];

    * Controlling navigation with canDeactivate
        Useful for example if client changes form and wants to quit the page before finish updating

        can-deactivate-guard.service.ts

            export interface CanComponentDeactivate {
                canDeactivate: () => Observable<boolean> | Promise<boolean> | boolean
            }

            export class CandDeactivateGuard implements CanDeactivate<CanComponentDeactivate> {
                
                canDeactivate(component: CanComponentDeactivate,
                    currentRoute: ActivatedRouteSnapshot,
                    currentState:  RouterStateSnapshot,
                    nextState?: RouterStateSnapshot) : Observable<boolean> | Promise<boolean> | boolean {

                        return component.canDeactivate();
                }
            }


        edit-server.component.ts
            export class EditServerComponent implements OnInit, CanComponentDeactivate {
                server: {id: number, name: string, status: string};
                serverName = '';
                serverStatus = '';
                allowEdit = false;
                chagesSaved = false;

                constructor(private serversService: ServersService,
                    private route: ActivatedRoute,
                    private router: Router) { }

                ngOnInit() {
                    console.log(this.route.snapshot.queryParams);
                    console.log(this.route.snapshot.fragment);
                    this.route.queryParams.subscribe(
                    (queryParams: Params) => {
                        this.allowEdit = queryParams['allowEdit'] === '1' ? true : false;
                    }
                    );
                    const id = +this.route.snapshot.params['id'];
                    this.server = this.serversService.getServer(id);
                    // Subscribe route params to update the id if params change
                    this.serverStatus = this.server.status;
                    this.serverName = this.server.name;
                }

                canDeactivate() : Observable<boolean> | Promise<boolean> | boolean{
                    if(!this.allowEdit){
                    return true;
                    }
                    if((this.serverName !== this.server.name || this.serverStatus !== this.server.status) && 
                    !this.chagesSaved){
                        return confirm('Do you want to discard the changes ?')
                    } else {
                    return true;
                    }

                }

            }

    * Passing static data to a route 
        error-page.component.html
            <p>{{ errorMessage }}</p>

        error-page.component.ts
            export class ErrorPageComponent implements OnInit {
                errorMessage: string;

                constructor(private route: ActivatedRoute) { }

                ngOnInit() {
                    //this.errorMessage = this.route.snapshot.data['message'];
                    this.route.data.subscribe(
                    (data: Data) => {
                        this.errorMessage = data['message'];
                    }
                    )
                }

            }

        app-routing.module.ts
            const appRoutes: Routes = [
                ...,
                {path: 'not-found', component: ErrorPageComponent, data: {message: 'Page not found! :('}},
                ...
            
            ];

    * Resolving Dynamic data with the resolve guard

        server-resolver.service.ts
            interface Server {
                id: number;
                name: string;
                status: string
            }

            @Injectable()
            export class ServerResolver implements Resolve<Server> {
                constructor(private serversService: ServersService){}
                
                resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) : Observable<Server> | Promise<Server> | Server{
                    return this.serversService.getServer(+route.params['id']);
                }
            }
        
        server.component.ts
            export class ServerComponent implements OnInit {
                server: {id: number, name: string, status: string};

                constructor(private serversService: ServersService,
                    private route: ActivatedRoute,
                    private router: Router) { }

                ngOnInit() {
                    this.route.data
                    .subscribe(
                        (data: Data) => {
                        this.server = data['server'];
                        }
                    )
                }
            }

        app-routing.module.ts
            const appRoutes: Routes = [
                ...,
                {path: ':id', component: ServerComponent, resolve: {server: ServerResolver}},
                ,...
            ];

    * Understanding location strategies
        
        using hash 
        
        @NgModule({
            imports: [
                RouterModule.forRoot(appRoutes, {useHash: true})
            ],
            exports: [RouterModule]
        })
        export class AppRoutingModule {

        }

#####################################################################################################
SECTION 13 - UNDERSTANDING OBSERVABLES
#####################################################################################################

    * A basic observable

        export class HomeComponent implements OnInit, OnDestroy {

        private firstObsSubscription: Subscription;

        constructor() { }

        ngOnInit(): void {
            this.firstObsSubscription = interval(1000).subscribe(
            count => {
                console.log(count);
            });
        }

        ngOnDestroy(): void {
            this.firstObsSubscription.unsubscribe();
        }
        }

    * Custom observable with emitter, error, and completion

        export class HomeComponent implements OnInit, OnDestroy {

            private firstObsSubscription: Subscription;

            constructor() { }

            ngOnInit(): void {
                const customIntervalObservable = Observable.create(
                observer => {
                    let count = 0;
                    setInterval( () => {
                    observer.next(count);
                    if(count == 2){
                        observer.complete();
                    }
                    if(count > 3){
                        observer.error(new Error('count is greater than 3'));
                    }
                    count++;
                    }, 1000);
                });

                this.firstObsSubscription = customIntervalObservable.subscribe( data => {
                    console.log(data);
                }, error =>  {
                    console.log(error);
                    alert(error.message);
                }, () => {
                    console.log('completed');
                });
            }

            ngOnDestroy(): void {
                this.firstObsSubscription.unsubscribe();
            }
        }
    
    * Using operators

        import { map, filter } from 'rxjs/operators';

        this.firstObsSubscription = customIntervalObservable.pipe(
        filter( data => {
            return data > 0;
        })
        ,map( (data: number) => {
            return 'Round: ' + (data + 1);
        })).subscribe( data => {
            console.log(data);
        }, error =>  {
            console.log(error);
            alert(error.message);
        }, () => {
            console.log('completed');
        });

    * Subjects (special type of observable) used to communicate accross different services
        
        user.service.ts
            import { Injectable, EventEmitter } from '@angular/core';
            import { Subject} from 'rxjs';

            @Injectable({providedIn: 'root'})
            export class UserService {
                activatedEmitter = new Subject<boolean>();
            }

        user.component.html
            <button class="btn btn-primary" (click)="onActivate()">Activate</button>
        
        user.component.ts

            export class UserComponent implements OnInit {
                id: number;

                constructor(private route: ActivatedRoute, private userService: UserService) {
                }

                onActivate(){
                    this.userService.activatedEmitter.next(true);
                }
            }

        app.component.html
              <p *ngIf="userActivated">Activated!</p>
        
        app.component.ts
            export class AppComponent implements OnInit, OnDestroy {
                userActivated = false;
                private activatedSub: Subscription;

                constructor(private userService: UserService) {}

                ngOnInit() {
                    this.activatedSub = this.userService.activatedEmitter.subscribe(didActivate => {
                    this.userActivated = didActivate;
                    });
                }

                ngOnDestroy(){
                    this.activatedSub.unsubscribe();
                }
            }

#####################################################################################################
SECTION 15 - HANDLING FORMS IN ANGULAR APPS
#####################################################################################################

    * Registering the controls

        <form>
            <div id="user-data">
                <div class="form-group">
                    <label for="username">Username</label>
                    <input 
                    type="text" 
                    id="username" 
                    class="form-control"
                    ngModel
                    name="username">
                </div>
            </div>
            <button class="btn btn-primary" type="submit">Submit</button>
        </form>

    * Submiting and using the form

        app.component.ts
            onSubmit(form: NgForm){
                console.log(form); -> consoles automatic javascript object created by angular automatically from form
            }

        app.component.html
            <form (ngSubmit)="onSubmit(f)" #f="ngForm">

    * Accessing form with view child

        app.component.ts
            @ViewChild('f', {static: true}) signupForm: NgForm; 

        app.component.html
            <form (ngSubmit)="onSubmit()" #f="ngForm">

    * Form validation and output error messages
        <div class="form-group">
            <label for="email">Mail</label>
            <input 
              type="email" 
              id="email" 
              class="form-control"
              ngModel
              name="email"
              required
              email
              #email="ngModel">
              <span class="help-block" *ngIf="!email.valid && email.touched">Please enter a valid email!</span>
        </div>