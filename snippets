List of Snippets/Concepts important inside the course

#####################################################################################################
SECTION 1 - GETTING STARTED
#####################################################################################################

* Angular CLI (Command Line Interface) commands to start a project

npm install -g @angular/cli
ng new [app_name]
cd [app_name]
ng serve

#####################################################################################################
SECTION 2 - THE BASICS
#####################################################################################################

* Creating a new component from the CLI
ng generate component [component_name]
ng g c [component_name]


* Referencing HTML and CSS in a component
Inside the @Component

referencing an external html:  templateUrl: './[component_name].component.html',
referencing an internal html:  template: `html comes here`
referencing an external css:    styleUrls: [ './path_to_css']
referencing an internal css:    styles: [`style { property: property }`]

* String interpolation
    - typescript 
        export class ServerComponent {
            serverId = 10;
            serverStatus = 'offline';

            getServerStatus(){
                return this.serverStatus;
            }
        }
    - html
        <p>Server with ID {{ serverId }} is {{ getServerStatus() }} </p>

* Property Binding
    - typescript
        export class ServersComponent implements OnInit {
            allowNewServer = false;

            constructor() { 
                setTimeout(() => {
                this.allowNewServer = true;
                } ,2000);
            }
        }
    - html
        <button [disabled]="!allowNewServer">Add server</button>
        <p [innerText]="allowNewServer"></p>

* Event Binding
    - typescript
        export class ServersComponent implements OnInit {
            allowNewServer = false;
            serverCreationStatus = 'No server was created'

            onCreateServer(){
                this.serverCreationStatus = 'Server was created'
            }

        }
    - html
        <button (click)="onCreateServer()">Add server</button>

* Two Way Binding
    - typescript
        export class ServersComponent implements OnInit {
            serverName = 'TestServer';

            onUpdateServerName(event: any){
                this.serverName = (<HTMLInputElement>event.target).value
            }
        }
    - html
        <p [innerText]="serverName"></p>
        <input 
            type="text"
            class="form-control"
            [(ngModel)]="serverName">

* ngIf directive
    <p *ngIf="serverCreated; else noServer">Server was created, servername is {{ serverName }} </p>
    <ng-template #noServer>
        <p>No server was created </p>
    </ng-template>

* ngFor directive
    <app-server *ngFor="let server of servers"></app-server>

* ngStyle directive and ngClass directive
    <p 
        [ngStyle]="{backgroundColor: getColor()}"
        [ngClass]="{online: serverStatus === 'online'}">
        Server with ID {{ serverId }} is {{ getServerStatus() }} 
    </p>


#####################################################################################################
SECTION 5 - COMPONENTS & DATABINDING DEEP DIVE
#####################################################################################################

* Binding to custom property
    - element typescript
        export class ServerElementComponent implements OnInit {
            @Input() element: {type: string, name: string, content: string};
        }
    - app html
        <app-server-element 
            *ngFor="let serverElement of serverElements"
            [element]="serverElement">
        </app-server-element>

    * Assigning it an alias
        - typescript
            @Input('propertyAlias')
        - html
            <element [propertyAlias] = "variable"></element>

* Binding to custom event
    - app typescript (listening event)
        onServerAdded(serverData: {serverName: string, serverContent: string}) {
            this.serverElements.push({
            type: 'server',
            name: serverData.serverName,
            content: serverData.serverContent
            }); 
        }

    - app html
        <app-cokpit 
            (serverCreated)="onServerAdded($event)"
            (bpCreated)="onBlueprintAdded($event)" >
        </app-cokpit>

    - element typescript (invoking event)
        export class CokpitComponent implements OnInit {
            @Output() serverCreated = new EventEmitter<{serverName: string, serverContent: string}>();

            onAddServer() {
                this.serverCreated.emit({
                serverName: this.newServerName, 
                serverContent: this.newServerContent
                });
            }
        }
    
    - element html
        <div>
            <label>Server Name</label>
            <input type="text" class="form-control" [(ngModel)]="newServerName">
            <label>Server Content</label>
            <input type="text" class="form-control" [(ngModel)]="newServerContent">
            <br>
            <button
            class="btn btn-primary"
            (click)="onAddServer()">Add Server</button>
        </div>

    * Assigning it alias
        - typescript
            @Output('bpCreated')
        - html
            (bpCreated)="onBlueprintAdded($event)" 

*  Changing view encapsulation
    @Component({
        encapsulation: ViewEncapsulation.None // sets css globally, other opts are none, emulated, and shadowdom
    })

* Using local references in templates
    - html
    <input type="text" class="form-control" [(ngModel)]="newServerName" #serverNameInput> (works in the element)
    serverNameInput.value catchs the value inserted in the input

    <button
        class="btn btn-primary"
        (click)="onAddServer(serverNameInput)">Add Server</button>

    - typescript
        onAddServer(nameInput: HTMLInputElement) {
            this.serverCreated.emit({
            serverName: nameInput.value, 
            serverContent: this.newServerContent
         });
  }

* Getting access to template and DOM with @ViewChild
    - html
        <input 
        type="text" 
        class="form-control"  
        #serverNameInput>

    - typescript
        export class CokpitComponent implements OnInit {
            @ViewChild('serverNameInput', {static: true}) serverContentInput: ElementRef;
         
            onAddServer(nameInput: HTMLInputElement) {
            console.log(this.serverContentInput);
            this.serverCreated.emit({
            serverName: nameInput.value, 
            serverContent: this.serverContentInput.nativeElement.value
            });
            }
        }

* Projecting content into components with ng-content
    - element html
        <div
        class="panel panel-default">
            <div class="panel-heading">{{ element.name }}
            </div>
            <div class="panel-body">
                <ng-content></ng-content>
            </div>
        </div>

    - parent html

        <app-server-element 
        *ngFor="let serverElement of serverElements"
        [srvElement]="serverElement">
          <p>
            <strong *ngIf="element.type === 'server'" style="color: red">{{ element.content }}</strong>
            <em *ngIf="element.type === 'blueprint'">{{ element.content }}</em>
          </p>
        </app-server-element>

    * The p tag content inside the >< will be injected into the element html

* Lifecycle Hooks
    - ngOnChanges
    - ngOnInit
    - ngDoCheck
    - ngAfterContentInit
    - ngAfterContentChecked
    - ngAfterViewInit
    - ngAfterViewChecked
    - ngOnDestroy

* Getting access to ng-content with content ContentChild
    - html
        <p #contentParagraph>
    - typescript
        @ContentChild('contentParagraph', {static: true}) paragraph : ElementRef;

        console.log('text content of paragraph ' + this.paragraph.nativeElement.textContent);


#####################################################################################################
SECTION 7 - DIRECTIVES DEEP DIVE
#####################################################################################################

    * Basic attribute directive
        typescript
            @Directive({
                selector: '[appBasicHighlight]'
            })
            export class BasicHighlightDirective implements OnInit{
                constructor(private elementRef: ElementRef) {
                }

                ngOnInit() {
                    this.elementRef.nativeElement.style.backgroundColor = 'green';
                }
            }
        html
            <p appBasicHighlight>Style with basic directive</p>

    * Improved attribute directive
        typescript
            @Directive({
                selector: '[appBetterHighlight]'
            })
            export class BetterHighlightDirective implements OnInit{
                constructor(private elRef: ElementRef, private renderer: Renderer2) { }

                ngOnInit(){
                    this.renderer.setStyle(this.elRef.nativeElement, 'background-color', 'blue')
                }
            }

        html
            <p appBetterHighlight>Style with basic directive</p>

    * Using HostListener to listen to host events
        @HostListener('mouseenter') mouseover(eventData: Event) {
            this.renderer.setStyle(this.elRef.nativeElement, 'background-color', 'blue')
        }

        @HostListener('mouseleave') mouseleave(eventData: Event) {
            this.renderer.setStyle(this.elRef.nativeElement, 'background-color', 'transparent')
        }
    
    * Using HostBinding to bind to host properties
        @HostBinding('style.backgroundColor') backgroundColor: string = 'transparent';

          @HostListener('mouseenter') mouseover(eventData: Event) {
            this.backgroundColor = 'blue';
        }

    * Binding to directive properties
        typescript
            @Directive({
                selector: '[appBetterHighlight]'
            })
            export class BetterHighlightDirective implements OnInit{
                @Input() defaultColor: string = 'transparent';
                @Input('appBetterHighlight') highlightColor: string = 'blue';
                @HostBinding('style.backgroundColor') backgroundColor: string = this.defaultColor;

                constructor(private elRef: ElementRef, private renderer: Renderer2) { }

                ngOnInit(){
                    this.backgroundColor = this.defaultColor;
                }

                @HostListener('mouseenter') mouseover(eventData: Event) {
                    this.backgroundColor = this.highlightColor;
                }

                @HostListener('mouseleave') mouseleave(eventData: Event) {
                    this.backgroundColor = this.defaultColor;
                }
            }
        html
            <p [appBetterHighlight]="'red'" defaultColor="yellow">Style with basic directive</p>
            <p [appBetterHighlight]="'red'" [defaultColor]="'yellow'">Style with basic directive</p>
    * Behind the scenes of structural directives 
        this

        <div *ngIf="!onlyOdd">
            <li
                class="list-group-item"
                [ngClass]="{odd: even % 2 !== 0}"
                [ngStyle]="{backgroundColor: even % 2 !== 0 ? 'yellow' : 'transparent'}"
                *ngFor="let even of evenNumbers">
                {{ even }}
            </li>
        </div>

        becomes

        <ng-template [ngIf]="!onlyOdd">
            <div>
                <li>
                    class="list-group-item"
                    [ngClass]="{odd: even % 2 !== 0}"
                    [ngStyle]="{backgroundColor: even % 2 !== 0 ? 'yellow' : 'transparent'}"
                    *ngFor="let even of evenNumbers">
                    {{ even }}
                </li>
            </div>
        </ng-template>

    * Structural Directive
        html
            <div *appUnless="onlyOdd">
                <li
                    class="list-group-item"
                    [ngClass]="{odd: even % 2 !== 0}"
                    [ngStyle]="{backgroundColor: even % 2 !== 0 ? 'yellow' : 'transparent'}"
                    *ngFor="let even of evenNumbers">
                        {{ even }}
                </li>
            </div>
        typescript
            @Directive({
                selector: '[appUnless]'
            })
            export class UnlessDirective {
                @Input() set appUnless(condition: boolean){
                    if(!condition){
                    this.vcRef.createEmbeddedView(this.templateRef);
                    } else {
                    this.vcRef.clear();
                    }
                }
                constructor(private templateRef: TemplateRef<any>, private vcRef: ViewContainerRef) { }
            }

    * ngSwitch
        <div [ngSwitch]="value">
            <p *ngSwitchCase="5">Value is 5</p>
            <p *ngSwitchCase="10">Value is 10</p>
            <p *ngSwitchCase="100">Value is 100</p>
            <p *ngSwitchDefault >Value is Default</p>
        </div>


#####################################################################################################
SECTION 9 - USING SERVICES AND DEPENDENCY INJECTION
#####################################################################################################
    * Creating a Service and Injecting it
        service example
            export class LoggingService {
                logStatusChange(status: string){
                    console.log('A server status changed, new status: ' + status);
                }
            }

        class that uses the service
            @Component({
                providers: [LoggingService]
            })
            export class AccountComponent {

                constructor(private loggingService: LoggingService) {}

                onSetTo(status: string) {
                    this.loggingService.logStatusChange(status);
                }
            }

    * Using a service into another service
            @Injectable()
            export class AccountService {
                accounts = [
                    {
                    name: 'Master Account',
                    status: 'active'
                    }
                ];

                constructor(private loggingService: LoggingService){}

                addAccount(name: string, status: string){
                    this.accounts.push({name: name, status: status});
                    this.loggingService.logStatusChange(status);
                }

            }
    
    * A service provided somewhere on module level is an app-wide Singleton (if it is not overwritten somewhere on component level).
    * A service provided in a component shares the same instance between this component and its descendants (if it is not overwritten there).
    
    * Providing a service globaly
        @NgModule({
            declarations: [
            ],
            imports: [
            ],
            providers: [ShoppingListService],
            
        })
        export class AppModule { }
            
#####################################################################################################
SECTION 11 - CHANGING PAGES WITH ROUTES
#####################################################################################################

    * Setting up and loading routes
        ts
            import { Routes, RouterModule } from '@angular/router'
            
            const appRoutes: Routes = [
                {path: '', component: HomeComponent},
                {path: 'users', component: UsersComponent},
                {path: 'servers', component: ServersComponent}
            ]

            @NgModule({
                declarations: [
                ],
                imports: [
                    RouterModule.forRoot(appRoutes)
                ],
                providers: [],
                bootstrap: []
            })
            export class AppModule { }
    
        html
            <router-outlet></router-outlet>
    * Navigating with router links
      <ul class="nav nav-tabs">
        <li 
          role="presentation" 
          routerLinkActive="active"
          [routerLinkActiveOptions]="{exact: true}">
          <a routerLink="/">Home</a></li>
        <li 
          role="presentation" 
          routerLinkActive="active"  -> Directive that appends the class active when path is active
          [routerLinkActiveOptions]="{exact: true}" -> Especify that just add active class if the full path is active
          >
          <a routerLink="/servers">Servers</a></li>
        <li 
          role="presentation" 
          routerLinkActive="active"
          [routerLinkActiveOptions]="{exact: true}">
          <a [routerLink]="['/users']">Users</a></li>
      </ul>

    * Navigating programatically
        import { Router } from '@angular/router';
        export class HomeComponent implements OnInit {

            constructor(private router: Router) { }

            onLoadServers(){
                this.router.navigate(['/servers']);
            }
        }

    * Navigate with relative path
        import { Router, ActivatedRoute } from '@angular/router';
        export class ServersComponent implements OnInit {
            private servers: {id: number, name: string, status: string}[] = [];

            constructor(private router: Router, private route: ActivatedRoute) { }

            onReload(){
                this.router.navigate(['servers'], {relativeTo: this.route})
            }

        }

        * the default relative path is the root path

    * Dinamically using parameters in routes
        const appRoutes: Routes = [
            {path: '', component: HomeComponent},
            {path: 'users/:id', component: UserComponent}
        ]

    * Fetching route parameters
      app.module.ts
        const appRoutes: Routes = [
            {path: 'users/:id/:name', component: UserComponent}
        ]

      user.component.ts
        export class UserComponent implements OnInit {
            user: {id: number, name: string};

            constructor(private route: ActivatedRoute) { }

            ngOnInit() {
                this.user = {
                    id: this.route.snapshot.params['id'],
                    name: this.route.snapshot.params['name']
                }
            
                this.route.params.subscribe(
                    (params) => {
                        this.user.id = params['id'];
                        this.user.name = params['name'];
                    }
                );
            }
        }

      user.component.html
        <p>User with {{ user.id }} loaded.</p>
        <p>User name is {{ user.name }}</p>
    
    * When using your own observables, remember to unsubscribe them
        import { Subscription } from 'rxjs';

        export class UserComponent implements OnInit, OnDestroy {
        
            paramsSubscription: Subscription;

            ngOnDestroy() {
                this.paramsSubscription.unsubscribe();
            }
            
        }

    * Passing query parameters and fragments
        static
            <a
                [routerLink]="['/servers', server.id]"
                [queryParams]="{allowEdit:'1'}"
                fragment="loading"
                href="#"
                class="list-group-item"
                *ngFor="let server of servers">
                {{ server.name }}
            </a>
        dinamic
            this.router.navigate(['/servers', id, 'edit'], {queryParams: {allowEdit: '1'}, fragment: 'loading'});

    * Retrieving query params and fragments
        
        constructor(private route: ActivatedRoute) { }
        
        ngOnInit() {
            console.log(this.route.snapshot.queryParams);
            console.log(this.route.snapshot.fragment);
            this.route.queryParams.subscribe();
            this.route.fragment.subscribe();
            this.route.params.subscribe();
        }

    * Nested (Child) routes
        const appRoutes: Routes = [
            {path: 'servers', component: ServersComponent, children: [
                {path: ':id', component: ServerComponent},
                {path: ':id/edit', component: EditServerComponent}
            ]}
        ]

        html (when using a child component, we need to add a router outlet )
            <router-outlet></router-outlet>

    * Using query params
        servers html
            <a
                [routerLink]="['/servers', server.id]"
                [queryParams]="{allowEdit: server.id === 3 ? '1' : '0'}"
                fragment="loading"
                href="#"
                class="list-group-item"
                *ngFor="let server of servers">
                {{ server.name }}
            </a>

        server html
            <button class="btn btn-primary" (click)="onEdit()">Edit Server</button>

        server ts
            export class ServerComponent implements OnInit {
                server: {id: number, name: string, status: string};

                constructor(private serversService: ServersService,
                    private route: ActivatedRoute,
                    private router: Router) { }

                ngOnInit() {
                    const id = +this.route.snapshot.params['id'];
                    this.server = this.serversService.getServer(1);
                    this.route.params
                    .subscribe(
                        (params: Params) => {
                        this.server = this.serversService.getServer(+params['id']);
                        }
                    )
                }

                onEdit(){
                    this.router.navigate(['edit'], {relativeTo: this.route, queryParamsHandling: 'preserve'});
                }
            }
        edit server ts
            export class ServerComponent implements OnInit {
                server: {id: number, name: string, status: string};
                constructor(private serversService: ServersService,
                    private route: ActivatedRoute) { }

                ngOnInit() {
                    this.route.queryParams.subscribe(
                    (queryParams: Params) => {
                        this.allowEdit = queryParams['allowEdit'] === '1' ? true : false;
                    }
                    );

                    this.server = this.serversService.getServer(1);
                    this.serverName = this.server.name;
                    this.serverStatus = this.server.status;
                }

        edit server html
            <h4 *ngIf="!allowEdit">You're not allowed to edit</h4>
            <div *ngIf="allowEdit">    
                ...
            </div>


    * Configuring the handling of query params
        This queryParamsHandling passes the params to the route we are navigating to

        export class ServerComponent implements OnInit {
            server: {id: number, name: string, status: string};

            constructor(private serversService: ServersService,
                private route: ActivatedRoute,
                private router: Router) { }


            onEdit(){
                this.router.navigate(['edit'], {relativeTo: this.route, queryParamsHandling: 'preserve'});
            }

        }
